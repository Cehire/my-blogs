(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{392:function(s,t,a){"use strict";a.r(t);var n=a(7),e=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"普通内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#普通内部类"}},[s._v("#")]),s._v(" 普通内部类")]),s._v(" "),t("p",[s._v("在一个类里面作为类的一个字段直接定义即可")]),s._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("package")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("cn"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("cehire")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" demo01 "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//讲一下内部类")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("InnerClass01")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",[s._v("在这里=="),t("code",[s._v("InnerClass01")]),s._v("==为类=="),t("code",[s._v("demo01")]),s._v("==的一个普通内部类，在这种定义方式下，普通内部类对象依赖外部类对象而存在，"),t("strong",[s._v("即创建一个普通内部类对象时首先需要创建其外部类对象")]),s._v("，我们在创建上述=="),t("code",[s._v("InnerClass01")]),s._v("==对象时首先要创建=="),t("code",[s._v("demo01")]),s._v("==对象。")]),s._v(" "),t("p",[s._v("这里的内部类就像外部类的一个属性字段一样，因此这个内部类对象要依赖于外部类对象而存在。")]),s._v(" "),t("blockquote",[t("p",[s._v("内部类对象可以访问外部类对象中=="),t("strong",[s._v("所有访问权限")]),s._v("==的字段，同时，外部类对象也可以通过内部类对象的引用来访问内部类中定义的=="),t("strong",[s._v("所有访问权限")]),s._v("==的字段")])]),s._v(" "),t("h2",{attrs:{id:"静态内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态内部类"}},[s._v("#")]),s._v(" 静态内部类")]),s._v(" "),t("p",[s._v("静态内部类作为外部类的静态成员而存在，"),t("strong",[s._v("创建一个类的静态内部类对象不需要依赖其外部类对象")])]),s._v(" "),t("blockquote",[t("p",[s._v("静态内部类就像外部类的一个静态成员一样，创建其对象无需依赖外部类对象，访问一个类的静态成员也无需依赖这个类的对象。与此同时，静态内部类中也无法访问外部类的非静态成员。"),t("strong",[s._v("外部类依然可以访问静态内部类对象的所有访问权限的成员")])])]),s._v(" "),t("h2",{attrs:{id:"匿名内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#匿名内部类"}},[s._v("#")]),s._v(" 匿名内部类")]),s._v(" "),t("blockquote",[t("p",[s._v("匿名内部类的使用方式")]),s._v(" "),t("ol",[t("li",[s._v("直接new一个接口，并实现这个接口声明的方法，这个过程中实际上会创建一个匿名内部类实现这个接口，并重写接口声明的方法，然后创建一个这个匿名内部类的对象并赋值给参数")]),s._v(" "),t("li",[s._v("new一个已经存在的类/抽象类，并选择性地实现这个类中的一个或者多个"),t("strong",[s._v("非final")]),s._v("方法，这个过程也会创建一个匿名内部类对象继承对应的类/抽象类，并"),t("strong",[s._v("重写")]),s._v("对应的方法")])]),s._v(" "),t("p",[s._v("同样的，在匿名内部类中可以使用外部类的属性，但是外部类却不能使用匿名内部类中定义的属性，因为是匿名内部类，外部类无法获取这个类的类名，也就无法得到属性信息，当然作为入参传入参数之后就能调用了")])]),s._v(" "),t("h2",{attrs:{id:"局部内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#局部内部类"}},[s._v("#")]),s._v(" 局部内部类")]),s._v(" "),t("blockquote",[t("p",[s._v("局部内部类使用的比较少，其声明在一个方法体/一段代码块的内部，而且不再定义类的定义域之内就无法使用，其提供的功能使用匿名内部类都可以实现，而匿名内部类更加简洁，因此使用得较少")])])])}),[],!1,null,null,null);t.default=e.exports}}]);