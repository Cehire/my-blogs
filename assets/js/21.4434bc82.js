(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{396:function(a,t,i){"use strict";i.r(t);var n=i(7),v=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"一-aop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-aop"}},[a._v("#")]),a._v(" 一 AOP")]),a._v(" "),t("p",[a._v("面向切面编程是作为面向对象的一种补充，将公共逻辑封装成切面，跟业务代码进行分离，可以减少系统的重复代码和降低模块之间的耦合度。切面就是那些与业务无关，但是所有的业务模块都会调用的公共逻辑。")]),a._v(" "),t("p",[a._v("AOP有两种实现方式：静态代理和动态代理")]),a._v(" "),t("h3",{attrs:{id:"静态代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态代理"}},[a._v("#")]),a._v(" 静态代理")]),a._v(" "),t("p",[a._v("静态代理：代理类在编译阶段生成，在编译阶段将"),t("strong",[a._v("通知")]),a._v("织入Java字节码中，也叫做编译时增强。"),t("strong",[a._v("AspectJ")]),a._v("使用的是静态代理。")]),a._v(" "),t("p",[a._v("缺点：代理对象需要与目标对象实现一样的接口，并且要实现接口的方法，会有冗余代码。同时，一旦接口增加方法，目标对象与代理对象都要维护。")]),a._v(" "),t("h3",{attrs:{id:"动态代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态代理"}},[a._v("#")]),a._v(" 动态代理")]),a._v(" "),t("p",[a._v("动态代理：代理类在"),t("strong",[a._v("程序运行时")]),a._v("创建，AOP框架不会去修改字节码，而是在内存中临时生成一个代理对象，在运行期间对业务方法进行增强，不会产生新类（？）。")]),a._v(" "),t("p",[a._v("详见之前的笔记")]),a._v(" "),t("ul",[t("li",[a._v("如果目标对象实现了接口，默认使用JDK动态代理（依赖接口使用反射）")]),a._v(" "),t("li",[a._v("如果目标对象没有实现接口，则使用CGLIB动态代理（使用继承）")]),a._v(" "),t("li",[a._v("可以强制指定CGLIB动态代理")])]),a._v(" "),t("h2",{attrs:{id:"ioc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ioc"}},[a._v("#")]),a._v(" IOC")]),a._v(" "),t("p",[a._v("控制反转，由Spring容器管理bean的整个生命周期。通过反射实现对其他对象的控制，包括初始化、创建、销毁等，解放手动创建对象的过程，同时降低类直接的耦合度")]),a._v(" "),t("ul",[t("li",[a._v("好处：降低了类之间的耦合，对象创建和初始化交给Spring容器管理，在需要的时候只需向容器进行申请")])]),a._v(" "),t("p",[a._v("DI（依赖注入）：在Spring创建对象的过程中，把对象依赖的属性注入到对象中")]),a._v(" "),t("ul",[t("li",[a._v("构造器注入")]),a._v(" "),t("li",[a._v("属性注入")])]),a._v(" "),t("h3",{attrs:{id:"ioc容器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ioc容器"}},[a._v("#")]),a._v(" ioc容器")]),a._v(" "),t("p",[a._v("Spring主要有两种ioc容器，实现了BeanFactory接口的简单容器和ApplicationContext高级容器")]),a._v(" "),t("ul",[t("li",[a._v("BeanFactory：懒汉模式，提供了最基本的ioc容器的功能")]),a._v(" "),t("li",[a._v("ApplicationContext：饿汉模式，拓展了BeanFactory")])]),a._v(" "),t("p",[a._v("ApplicationContext提供了BeanFactory没有的新特性：")]),a._v(" "),t("ol",[t("li",[a._v("支持多语言版本")]),a._v(" "),t("li",[a._v("支持多种途径获取Bean定义信息")]),a._v(" "),t("li",[a._v("支持应用时间，方便管理Bean")])]),a._v(" "),t("h3",{attrs:{id:"beandefinition"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#beandefinition"}},[a._v("#")]),a._v(" BeanDefinition")]),a._v(" "),t("p",[a._v("BeanDefinition用于管理Spring应用的对象和对象之间的依赖关系，是对象依赖关系的数据抽象")]),a._v(" "),t("h3",{attrs:{id:"容器初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器初始化"}},[a._v("#")]),a._v(" 容器初始化")]),a._v(" "),t("p",[a._v("ioc容器初始化过程：BeanDefinition的资源定位、解析和注册")]),a._v(" "),t("ol",[t("li",[a._v("从XML中读取配置文件")]),a._v(" "),t("li",[a._v("将bean标签解析成BeanDefinition，如解析property元素，并注入到BeanDefinition实例中")]),a._v(" "),t("li",[a._v("将BeanDefinition注册到容器BeanDefinitionMap中")]),a._v(" "),t("li",[a._v("BeanFactory根据BeanDefinition的定义信息创建实例化和初始化bean")])]),a._v(" "),t("ul",[t("li",[a._v("单例bean的初始化及依赖注入"),t("strong",[a._v("一般")]),a._v("都在容器初始化阶段进行，只有懒加载的单例是在应用第一次调用getBean()时进行初始化和依赖注入")]),a._v(" "),t("li",[a._v("多例bean在容器启动时不实例化，即使设置lazy-init为false也没用，只有调用量getBean()才进行实例化。loadBeanDefinitions采用了模板模式，具体加载BeanDefinition的逻辑由各个子类完成")])]),a._v(" "),t("h3",{attrs:{id:"bean生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bean生命周期"}},[a._v("#")]),a._v(" Bean生命周期")])])}),[],!1,null,null,null);t.default=v.exports}}]);