(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{394:function(e,t,v){"use strict";v.r(t);var _=v(7),a=Object(_.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"integer-byte、short、long、character-的缓存机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#integer-byte、short、long、character-的缓存机制"}},[e._v("#")]),e._v(" Integer（Byte、Short、Long、Character）的缓存机制")]),e._v(" "),t("p",[e._v("这几个类都是具有缓存机制的类。缓存工作都是在"),t("strong",[e._v("静态块")]),e._v("中完成，在类生命周期的"),t("strong",[e._v("初始化阶段")]),e._v("执行。")]),e._v(" "),t("p",[e._v("缓存的范围为：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Byte、Short、Integer、Long为-128~127")])]),e._v(" "),t("li",[t("p",[e._v("Character为0~127")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("只有")]),e._v("Integer可以通过JVM参数指定缓存范围")]),e._v(" "),t("blockquote",[t("p",[e._v("Integer的缓存上界high可以通过JVM参数指定，会取指定值与127的最大值，并且不超过Integer的表示范围，"),t("strong",[e._v("但是下界low不能指定，只能为-128")])])])])]),e._v(" "),t("p",[e._v("注意：")]),e._v(" "),t("ul",[t("li",[e._v("整型的包装类valueOf方法返回对象时，在缓存范围内，会返回缓存对象")]),e._v(" "),t("li",[e._v("浮点型的包装类valueOf方法返回新的对象")]),e._v(" "),t("li",[e._v("布尔型的包装类valueOf方法返回Boolean类的静态常量TRUE|FALSE")])]),e._v(" "),t("p",[t("strong",[e._v("对应包装类调用"),t("code",[e._v("valueOf()")]),e._v("方法即可装箱，对应包装类对象调用"),t("code",[e._v("基本数据类型Value()")]),e._v("方法即可拆箱")])]),e._v(" "),t("h3",{attrs:{id:"构造器是否可以被重写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造器是否可以被重写"}},[e._v("#")]),e._v(" 构造器是否可以被重写")]),e._v(" "),t("p",[e._v("构造器是不能被继承的，因为每个类的类名都不相同，而构造器名称与类名相同，所以根本谈不上继承，由于构造器不能继承，所以不能被重写，但是构造器可以被重载")]),e._v(" "),t("h3",{attrs:{id:"和-equals的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#和-equals的区别"}},[e._v("#")]),e._v(" "),t("code",[e._v("==")]),e._v(" 和 "),t("code",[e._v("equals")]),e._v("的区别")]),e._v(" "),t("p",[t("code",[e._v("==")]),e._v("是等于比较运算符，比较基本类型变量时，比较的是值；比较引用变量时，比较的是两个引用变量是否指向同一对象")]),e._v(" "),t("p",[t("code",[e._v("equals()")]),e._v("是Object类的方法，我们可以重写"),t("code",[e._v("equals()")]),e._v("方法来按照我们指定的规则进行比较")]),e._v(" "),t("h3",{attrs:{id:"对象拷贝-浅克隆和深克隆的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象拷贝-浅克隆和深克隆的区别"}},[e._v("#")]),e._v(" 对象拷贝（浅克隆和深克隆的区别）")]),e._v(" "),t("p",[e._v("可以实现Cloneable接口并且重写Object类中的clone()方法，浅克隆下，只会克隆对象的引用，实际上这个引用和原引用还是指向同一个对象，e1修改后e2中的属性也会被修改。深克隆下连对象都会复制一份，e1,e2不会互相干扰，要通过Cloneable接口实现深克隆，那么该类中的引用对象属性也需要实现Cloneable接口")]),e._v(" "),t("p",[e._v("也可以实现Serializable接口实现深克隆")])])}),[],!1,null,null,null);t.default=a.exports}}]);