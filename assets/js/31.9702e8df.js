(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{413:function(t,v,_){"use strict";_.r(v);var a=_(7),i=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[v("strong",[t._v("本文参考")]),t._v("：[CSDN] 老鼠只爱大米：Java中各类修饰符的使用总结（看完这篇就够了）")]),t._v(" "),v("p",[t._v("Java的修饰符根据修饰的对象不同，分为类修饰符、方法修饰符、变量修饰符，其中每种修饰符又分为访问控制修饰符和非访问控制修饰符。访问控制存在的原因：1. 让客户端程序员无法触及他们不该触及的部分 2. 允许库设计者可以改变类内部的工作方式而不用担心影响到客户端程序员")]),t._v(" "),v("h2",{attrs:{id:"一、类修饰符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、类修饰符"}},[t._v("#")]),t._v(" 一、类修饰符")]),t._v(" "),v("p",[v("strong",[t._v("访问修饰符：公共类修饰符public")])]),t._v(" "),v("p",[t._v("公共类修饰符public：Java中类的访问控制符只有public，即公共的。每个Java程序有且只有一个类是public，它被称为主类，其他外部类无访问控制修饰符，具有包访问性。"),v("strong",[t._v("注意")]),t._v("：一个类的内部类可以被其他访问控制符如protected、default、private修饰，相当于类的内部成员。")]),t._v(" "),v("p",[v("strong",[t._v("注意")]),t._v("：Java类或属性如果缺省访问控制修饰符，就属于default类型修饰符，但实际上并不能用default定义类或者变量，只是为了方便表示缺省访问修饰符的情况")]),t._v(" "),v("p",[v("strong",[t._v("非访问控制符：抽象类修饰符abstract、最终类修饰符final")])]),t._v(" "),v("ol",[v("li",[t._v("抽象类修饰符abstract：用abstract修饰符修饰的类，被称为抽象类")]),t._v(" "),v("li",[t._v("最终类修饰符final：当不允许一个类被继承时可以用修饰符final修饰为最终类，被定义为final的类通常是一些具有固定作用，用来完成某种标准的类")]),t._v(" "),v("li",[t._v("类缺省访问控制符：如果一个类没有访问控制符，说明它具有缺省的访问控制符特性。此时这个类只能被"),v("strong",[t._v("同一个包中的类访问或引用")]),t._v("。这一访问特性又称为包访问性")])]),t._v(" "),v("h2",{attrs:{id:"二、方法修饰符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、方法修饰符"}},[t._v("#")]),t._v(" 二、方法修饰符")]),t._v(" "),v("p",[v("strong",[t._v("访问控制符：公共访问控制符public、保护访问控制符protected、缺省默认访问控制符、私有访问控制符private")])]),t._v(" "),v("ol",[v("li",[t._v("public：声明该方法为公共方法，可以跨类和跨包访问")]),t._v(" "),v("li",[t._v("protected：若使用protected限制父类的方法，则该方法仅父类和子类内部可以调用")]),t._v(" "),v("li",[t._v("缺省访问控制符：只能在同一个包内访问")]),t._v(" "),v("li",[t._v("private：私有的，只能被本类的对象访问")])]),t._v(" "),v("p",[v("strong",[t._v("非访问控制修饰符：抽象方法修饰符abstract、静态方法修饰符static、最终方法修饰符final、本地方法控制符native、同步方法控制符synchronized")])]),t._v(" "),v("ol",[v("li",[t._v("abstract：abstract修饰的方法称为抽象方法。抽象方法只有方法头，没有方法体和具体实现")]),t._v(" "),v("li",[t._v("static：用static修饰的方法称为静态方法。静态方法是属于整个类的方法，它不能操纵和处理属于某个对象的成员变量，而只能处理属于整个类的成员变量（类成员变量），即static方法只能处理static域")]),t._v(" "),v("li",[t._v("final：用final修饰的方法称为最终方法。最终方法是功能和内部语句不能更改的方法，即最终方法不能被重写覆盖。final固定了方法锁具有的功能和操作，防止当前子类对父类关键方法的错误定义，保证了程序的安全性和正确性。"),v("strong",[t._v("所有被private修饰符限定的私有的方法以及所有包含在final类中的方法都被认为是最终方法。")])]),t._v(" "),v("li",[t._v("native：用native修饰的方法称为本地方法。为了提高程序的运行速度，需要用其它高级语言书写程序的方法体，那么该方法可以定义为本地方法用修饰符native来修饰")]),t._v(" "),v("li",[t._v("synchronize：该修饰符主要用于多线程程序中的协调和同步。")])]),t._v(" "),v("h2",{attrs:{id:"三、变量修饰符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、变量修饰符"}},[t._v("#")]),t._v(" 三、变量修饰符")]),t._v(" "),v("p",[v("strong",[t._v("访问控制符：公共访问控制符public、保护访问控制符protected、缺省访问控制符、私有访问控制符private")])]),t._v(" "),v("ol",[v("li",[t._v("public：用public修饰的域称为公共域。由于public修饰符会降低运行的安全性和数据的封装性，所以一般应减少public域的使用")]),t._v(" "),v("li",[t._v("private：private修饰的变量只能被该类自身所访问，不能被其他任何类（包括子类访问）")]),t._v(" "),v("li",[t._v("protected：用protected修饰的成员变量可以被三种类所引用：a. 该类自身；b. 同一个包中的其他类；c. 其它包中的子类。使用protected的主要作用是允许其他包中的子类来访问父类的特定属性")]),t._v(" "),v("li",[t._v("缺省访问控制符：没有访问控制符或者是用default修饰的成员变量可以被该类本身或同一包中的其他类访问。")])]),t._v(" "),v("p",[v("strong",[t._v("非访问控制符：静态域修饰符static、最终域修饰符final、共享域修饰符volatile、暂时性域修饰符transient")])]),t._v(" "),v("ol",[v("li",[t._v("static：用static修饰的成员变量仅属于类的变量，而不属于任何具体的对象，静态成员变量的值是保存在类的内存区域的公共存储单元，而不是保存在某一个对象的内存区间。该类的任一对象访问到它时取到的都是相同的数据")]),t._v(" "),v("li",[t._v("final：final是用来定义常量的。一个类的域（成员变量）如果被final修饰，则它的取值在程序的整个执行过程中都是不变的")]),t._v(" "),v("li",[t._v("volatile：volatile说明这个成员变量可能被几个线程所控制和修改。也就是说在程序的运行过程中，这个成员变量可能被其他的程序影响或改变它的取值。通常volatile用来修饰接受外部输入的域")]),t._v(" "),v("li",[t._v("transient：transient用来定义一个暂时性变量。用transient限定的暂时性变量，将指定Java虚拟机认定该暂时性变量不属于永久状态，以实现不同对象的存档功能。否则，类中所有的对象都是对象永久状态的一部分，存储对象时必须同时保存这些变量")])]),t._v(" "),v("h2",{attrs:{id:"四、访问控制修饰符总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、访问控制修饰符总结"}},[t._v("#")]),t._v(" 四、访问控制修饰符总结")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("访问级别")]),t._v(" "),v("th",[t._v("访问控制修饰符")]),t._v(" "),v("th",[t._v("同类")]),t._v(" "),v("th",[t._v("同包")]),t._v(" "),v("th",[t._v("子类（不同包）")]),t._v(" "),v("th",[t._v("不同包（其他类）")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("公共")]),t._v(" "),v("td",[t._v("public")]),t._v(" "),v("td",[t._v("允许")]),t._v(" "),v("td",[t._v("允许")]),t._v(" "),v("td",[t._v("允许")]),t._v(" "),v("td",[t._v("允许")])]),t._v(" "),v("tr",[v("td",[t._v("受保护")]),t._v(" "),v("td",[t._v("protected")]),t._v(" "),v("td",[t._v("允许")]),t._v(" "),v("td",[t._v("允许")]),t._v(" "),v("td",[t._v("允许")]),t._v(" "),v("td",[t._v("不允许")])]),t._v(" "),v("tr",[v("td",[t._v("默认")]),t._v(" "),v("td",[t._v("缺省修饰符")]),t._v(" "),v("td",[t._v("允许")]),t._v(" "),v("td",[t._v("允许")]),t._v(" "),v("td",[t._v("不允许")]),t._v(" "),v("td",[t._v("不允许")])]),t._v(" "),v("tr",[v("td",[t._v("私有")]),t._v(" "),v("td",[t._v("private")]),t._v(" "),v("td",[t._v("允许")]),t._v(" "),v("td",[t._v("不允许")]),t._v(" "),v("td",[t._v("不允许")]),t._v(" "),v("td",[t._v("不允许")])])])]),t._v(" "),v("p",[v("strong",[t._v("注意")]),t._v("：protected修饰的属性或方法，允许不同包的子类中访问。注意这里的访问方式是通过继承访问父类中的protected属性或者方法，而不是直接通过父类实例访问protected属性或方法")])])}),[],!1,null,null,null);v.default=i.exports}}]);