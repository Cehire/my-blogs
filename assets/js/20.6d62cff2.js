(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{395:function(t,e,_){"use strict";_.r(e);var a=_(7),l=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"索引概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引概述"}},[t._v("#")]),t._v(" 索引概述")]),t._v(" "),e("p",[e("strong",[t._v("索引是帮助MySQL高效获取数据的数据结构（有序）")]),t._v("。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在这些数据库上实现高级查找算法。")]),t._v(" "),e("p",[t._v("无索引的情况下会进行全表扫描，效率很低")]),t._v(" "),e("ul",[e("li",[t._v("优点：提高数据检索效率，降低数据库的IO成本；通过索引对数据进行排序，降低数据排序的成本，降低CPU的消耗")]),t._v(" "),e("li",[t._v("缺点：索引列占用空间；提高查询效率，同时也降低更新表的速度，对表进行增删改的时候效率较低")])]),t._v(" "),e("h2",{attrs:{id:"索引结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引结构"}},[t._v("#")]),t._v(" 索引结构")]),t._v(" "),e("p",[t._v("MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("索引结构")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("描述")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("B+Tree索引")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("最常见的索引类型，大部分引擎都支持B+Tree索引")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("Hash索引")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("R-tree（空间索引）")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("Full-text（全文索引）")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("是一种通过建立倒排索引，快速匹配文档的方式，类似于ES")])])])]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("索引")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("InnoDB")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("MyISAM")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("Memory")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("B+tree")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("支持")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("Hash")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("-")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("-")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("支持")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("R-tree")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("-")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("-")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("Full-text")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("5.6后支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("-")])])])]),t._v(" "),e("p",[t._v("==我们平常说的索引，如果没有特别指明，都是指B+树结构组织的索引==")]),t._v(" "),e("hr"),t._v(" "),e("h3",{attrs:{id:"b-tree-多路平衡查找树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-tree-多路平衡查找树"}},[t._v("#")]),t._v(" B-Tree（多路平衡查找树）")]),t._v(" "),e("h3",{attrs:{id:"hash索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hash索引"}},[t._v("#")]),t._v(" Hash索引")]),t._v(" "),e("p",[t._v("特点：")]),t._v(" "),e("ul",[e("li",[t._v("Hash索引只能用于对等比较，不支持范围查询")]),t._v(" "),e("li",[t._v("无法利用索引完成排序操作")]),t._v(" "),e("li",[t._v("查询效率高")])]),t._v(" "),e("p",[t._v("存储引擎支持：在MySQL中，支持hash索引的是memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+tree索引在指定条件下自动构建的")]),t._v(" "),e("p",[t._v("==InnoDB为什么使用B+Tree索引==")]),t._v(" "),e("hr"),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("分类")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("含义")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("特点")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("关键字")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("主键索引")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("针对于表中主键创建的索引")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("默认自动创建，只能有一个")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("PRIMARY")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("唯一索引")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("避免同一个表中数据列中值的重复")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("可以有多个")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("UNIQUE")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("常规索引")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("快速定位特定")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("可以有多个")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("全文索引")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("全文索引查找的是文本中的关键词，而不是比较索引中的值")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("可以有多个")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("FULLTEXT")])])])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("在InnoDB存储引擎中，根据索引的存储形式，又可以分为聚集索引和二级索引")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("分类")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("含义")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("特点")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("聚集索引")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("必须有且只有一个")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("二级索引")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("可以存在多个")])])])]),t._v(" "),e("p",[t._v("聚集索引选取规则：")]),t._v(" "),e("ul",[e("li",[t._v("如果存在主键，主键索引就是聚集索引")]),t._v(" "),e("li",[t._v("如果不存在主键，将使用第一个唯一索引作为聚集索引")]),t._v(" "),e("li",[t._v("如果以上都没有则会自动生成一个rowid作为隐藏的聚集索引")])]),t._v(" "),e("h2",{attrs:{id:"索引语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引语法"}},[t._v("#")]),t._v(" 索引语法")]),t._v(" "),e("ul",[e("li",[t._v("创建索引："),e("code",[t._v("create [unique|fulltext] index index_name on table_name(index_col_name,...)")])]),t._v(" "),e("li",[t._v("查看索引："),e("code",[t._v("show index from table_name")])]),t._v(" "),e("li",[t._v("删除索引："),e("code",[t._v("drop index index_name on table_name")])])]),t._v(" "),e("div",{staticClass:"language-mysql extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 为name字段创建索引，name可能重复\ncreate index idx_user_name on tb_user(name);\n# 为phone创建唯一索引\ncreate unique index idx_user_phone on tb_user(phone);\n# 为profession、age、status创建联合索引\ncreate idx_user_pro_age_sta on tb_user(profession,age,status);\n# 为email建立合适的索引来提升查询效率\ncreate fulltext index idx_user_email on tb_user(email);\n# 查看索引\nshow index from tb_user;\n# 删除name表的索引\ndrop index idx_user_name on tb_user;\n")])])]),e("h2",{attrs:{id:"sql性能分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sql性能分析"}},[t._v("#")]),t._v(" SQL性能分析")]),t._v(" "),e("p",[t._v("MySQL客户端连接成功后，通过"),e("code",[t._v("show [session|global] status命令可以提供服务器状态信息。")])]),t._v(" "),e("ul",[e("li",[t._v("insert、update、delete、select的访问频次："),e("code",[t._v("show global status like 'Com_______'(7个下划线)")])])]),t._v(" "),e("h3",{attrs:{id:"慢查询日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#慢查询日志"}},[t._v("#")]),t._v(" 慢查询日志")]),t._v(" "),e("p",[t._v("慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位秒，默认10秒，可以通过"),e("code",[t._v("show variables like 'slow_query_log'")]),t._v("查询），的所有的SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：")]),t._v(" "),e("div",{staticClass:"language-mysql extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 开启慢查询开关\nslow_query_log=1\n#设置慢日志的时间为2秒\nlong_query_time=2\n")])])]),e("p",[t._v("配置完毕后，重启MySQL服务器，慢日志会记录在/var/lib/mysql/localhost-slow.log")]),t._v(" "),e("h3",{attrs:{id:"profile详情"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#profile详情"}},[t._v("#")]),t._v(" profile详情")]),t._v(" "),e("p",[t._v("通过have_profiling参数，能够看到当前MySQL是否支持profile操作："),e("code",[t._v("select @@have_profiling")])]),t._v(" "),e("p",[t._v("默认profiling是关闭的，可以通过set语句在session或global级别开启profiling："),e("code",[t._v("set [session|global] profiling = 1")])]),t._v(" "),e("div",{staticClass:"language-mysql extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("#查看每一条SQL的耗时基本情况\nshow profiles;\n#查看指定query_id的SQL语句各个阶段的耗时情况\nshow profile for query query_id;\n#查看指定query_id的CPU的使用情况\nshow profile cup for query query_id;\n")])])]),e("h3",{attrs:{id:"explain执行计划"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#explain执行计划"}},[t._v("#")]),t._v(" ==explain执行计划==")]),t._v(" "),e("p",[t._v("explain或者desc命令获取MySQL如何执行select语句的信息，包括在select语句执行过程中表如何连接和连接的顺序。："),e("code",[t._v("explain/desc select 字段列表 from 表名 where 条件")])]),t._v(" "),e("p",[t._v("各字段含义：")]),t._v(" "),e("ul",[e("li",[t._v("id：select查询的序列号，表示查询中执行力select子句或者是操作表的顺序（id相同，执行顺序从上到下；id值不同，值越大越优先执行）")]),t._v(" "),e("li",[t._v("select_type：表示select的类型，常见的取值有simple（简答表，即不适用表连接或者子查询）、primary（主查询，即外层的查询）、union（union中的第二个或者后面的查询语句）、subquery（select/where之后包含了子查询）等")]),t._v(" "),e("li",[t._v("type：表示连接类型，性能由好到差的连接类型为null，system，const，eq_ref、ref、range、index、all")]),t._v(" "),e("li",[t._v("possible_key：显示可能应用在这张表上的索引，一个或多个")]),t._v(" "),e("li",[t._v("key：实际使用的索引")]),t._v(" "),e("li",[t._v("key_len：索引中使用的字节数，改值为索引字段最大可能长度，并非使用长度")]),t._v(" "),e("li",[t._v("rows：执行查询的长度（预估）")]),t._v(" "),e("li",[t._v("filtered：返回结果的行数占需要读取的行数的百分比")]),t._v(" "),e("li",[t._v("extra：额外信息")])]),t._v(" "),e("h2",{attrs:{id:"索引使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引使用"}},[t._v("#")]),t._v(" 索引使用")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("最左前缀法则：如果索引了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列，如果跳跃某一列，"),e("strong",[t._v("索引将部分失效（后面的字段索引失效）")])])]),t._v(" "),e("li",[e("p",[t._v("联合索引中，出现范围查询，范围查询"),e("strong",[t._v("右侧")]),t._v("的索引列失效，"),e("strong",[t._v("在业务允许的范围内使用大于等于或者小于等于的范围查询")])])]),t._v(" "),e("li",[e("p",[t._v("不要在索引列上进行运算操作，否则索引失效")])]),t._v(" "),e("li",[e("p",[t._v("字符串类型使用时，不加引号，索引将失效（隐式类型转换导致），==所以一定要加引号==")])]),t._v(" "),e("li",[e("p",[t._v("如果使用头部模糊匹配，索引将失效；如果仅是尾部模糊匹配，索引不会失效（因为B+树是排序树）")])]),t._v(" "),e("li",[e("p",[t._v("用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到")])]),t._v(" "),e("li",[e("p",[t._v("如果MySQL评估使用索引比全表更慢，则不使用索引")])])]),t._v(" "),e("h3",{attrs:{id:"sql提示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sql提示"}},[t._v("#")]),t._v(" SQL提示")]),t._v(" "),e("p",[t._v("在from后加入提示使MySQL按照我们指定的索引查找")]),t._v(" "),e("ul",[e("li",[t._v("use index（建议）")]),t._v(" "),e("li",[t._v("ignore index")]),t._v(" "),e("li",[t._v("force index（强制）")])]),t._v(" "),e("h3",{attrs:{id:"覆盖索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#覆盖索引"}},[t._v("#")]),t._v(" 覆盖索引")]),t._v(" "),e("p",[t._v("覆盖索引指的是查询中使用了索引，并且需要返回的列在该索引中已经全部能够找到。"),e("strong",[t._v("尽量使用")]),t._v("覆盖索引，减少select *")]),t._v(" "),e("p",[t._v("extra列的信息：")]),t._v(" "),e("ul",[e("li",[t._v("using index condition：查找使用了索引，但是需要回表查询数据")]),t._v(" "),e("li",[t._v("using where；using index：查找使用了索引，但是需要的数据都在索引列中能找到，索引不需要回表查询数据（索引列包含查询列）")])]),t._v(" "),e("h3",{attrs:{id:"前缀索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前缀索引"}},[t._v("#")]),t._v(" 前缀索引")]),t._v(" "),e("ul",[e("li",[t._v("语法："),e("code",[t._v("create index idx_xxxx on table_name(column(n))")])]),t._v(" "),e("li",[t._v("前缀长度：可以根据索引的选择性来决定，选择先是指不重复的索引值（基数）和数据表的记录总数的笔直，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的")])]),t._v(" "),e("div",{staticClass:"language-mysql extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("select count(distinct email)/count(*) from tb_user;\nselect count(distinct substring(email,1,5))/count(*) from tb_user;\n")])])]),e("h2",{attrs:{id:"索引设计原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引设计原则"}},[t._v("#")]),t._v(" 索引设计原则")]),t._v(" "),e("ol",[e("li",[t._v("针对于数据量较大，且查询比较频繁的表建立索引")]),t._v(" "),e("li",[t._v("针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引")]),t._v(" "),e("li",[t._v("尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高")]),t._v(" "),e("li",[t._v("如果是字符串类型的字段，字段的长度较长，可以针对字段的特点，建立前缀索引")]),t._v(" "),e("li",[t._v("尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免徽标，提高查询效率")]),t._v(" "),e("li",[t._v("要控制索引的数量，索引越多，维护索引结构的代价越大，影响增删改的效率")]),t._v(" "),e("li",[t._v("如果索引列不能存储null值，请在创建表的时候用not null约束。当优化器知道每列是否包含null值时，它可以更好地确定哪个索引最有效地用于查询")])]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"sql优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sql优化"}},[t._v("#")]),t._v(" SQL优化")]),t._v(" "),e("h3",{attrs:{id:"插入数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插入数据"}},[t._v("#")]),t._v(" 插入数据")]),t._v(" "),e("p",[t._v("insert优化：")]),t._v(" "),e("ul",[e("li",[t._v("使用批量插入插入多条数据（500-1000条）如果数据太多，可以分为几次insert插入")]),t._v(" "),e("li",[t._v("手动提交事务（减少事务的开启与关闭）")]),t._v(" "),e("li",[t._v("主键顺序插入（见主键优化）：主键插入性能高于乱序插入")]),t._v(" "),e("li",[t._v("如果一次性需要插入"),e("strong",[t._v("大批量数据")]),t._v("，可以使用MySQL提供的load指令进行插入")]),t._v(" "),e("li",[t._v("步骤")])]),t._v(" "),e("div",{staticClass:"language-mysql extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 客户端连接服务器时，加上参数 --local-infile\nmysql --local-infile -u root -p\n#查看全局参数local_infile\nselect @@local_infile;\n# 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关\nset global local_infile = 1;\n# 执行local指令将准备好的数据加载到表结构当中\nload data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\\n';\n")])])]),e("h3",{attrs:{id:"主键优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主键优化"}},[t._v("#")]),t._v(" 主键优化")]),t._v(" "),e("p",[t._v("数据组织方式：再InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称之为索引组织表")]),t._v(" "),e("p",[t._v("页分裂：")]),t._v(" "),e("p",[t._v("页可以为空，也可以填充一般，也可以填充100%。每个页包含了2-N行数据，根据主键排列。主键乱序插入的情况下容易产生页分裂")]),t._v(" "),e("p",[t._v("页合并：")]),t._v(" "),e("p",[t._v("当删除一行记录时，实际上记录并没有被物理删除，只是被标记为删除并且它的空间变得允许被其他记录声明使用，当页中删除的记录达到merge_threshold（默认为页的50%），InnoDB会开始寻址最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。")]),t._v(" "),e("p",[t._v("==注==：merge_threshold为合并页的阈值，可以自己设置，再创建表或者创建索引时指定")]),t._v(" "),e("p",[e("strong",[t._v("主键设计原则")]),t._v("：")]),t._v(" "),e("ul",[e("li",[t._v("在满足业务的需求下，尽量降低主键的长度")]),t._v(" "),e("li",[t._v("插入数据时，尽量选择顺序插入，选择使用auto_increment自增主键")]),t._v(" "),e("li",[t._v("尽量不要使用UUID或是其他自然主键做主键，如身份证号")]),t._v(" "),e("li",[t._v("业务操作时，尽量避免对主键的修改")])]),t._v(" "),e("h3",{attrs:{id:"order-by优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#order-by优化"}},[t._v("#")]),t._v(" order by优化")]),t._v(" "),e("ol",[e("li",[t._v("using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后再排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结构的排序都叫filesort排序")]),t._v(" "),e("li",[t._v("using index：通过 有序索引顺序扫描直接返回有序数据，不需要额外排序，操作效率高")])]),t._v(" "),e("div",{staticClass:"language-mysql extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 没有创建索引时，根据age,phone排序\nexplain select id,age,phone from tb_user order by age,phone;\n# 创建索引\ncreate index idx_user_age_phone_aa on tb_user(age,phone)\n#创建索引后，根据age,phone进行升序排序\nexplain select id,age,phone from tb_user order by age,phone;\n#创建索引后，根据age,phone进行降序排序\nexplain select id,age,phone from tb_user order by age desc,phone desc;\n")])])]),e("ul",[e("li",[t._v("根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则")]),t._v(" "),e("li",[t._v("尽量使用覆盖索引")]),t._v(" "),e("li",[t._v("多字段排序，一个升序一个降序，此时需要注意联合索引再创建时的规则（ASC/DESC）")]),t._v(" "),e("li",[t._v("如果不可避免地出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_seize（默认256k）")])]),t._v(" "),e("h3",{attrs:{id:"group-by优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#group-by优化"}},[t._v("#")]),t._v(" group by优化")]),t._v(" "),e("ul",[e("li",[t._v("在分组操作时，可以通过索引来提高效率")]),t._v(" "),e("li",[t._v("在分组操作时，索引的使用也是满足最左前缀法则的")])]),t._v(" "),e("div",{staticClass:"language-mysql extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("create index idx_user_pro_age_sta on tb_user(profession,age,status);\n#\nexplain select profession,count(*) from tb_user group by profession;\n# 创建了临时表，效率较慢\nexplain select age,count(*) from tb_user group by age;\n# 符合最左前缀法则，使用了索引，效率较快\nexplain select age,count(*) from tb_user group by profession , age;\n# where条件也能满足最左前缀法则\nexplain select age,count(*) from tb_user where profession = '软件工程' group by age;\n")])])]),e("h3",{attrs:{id:"limit优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#limit优化"}},[t._v("#")]),t._v(" limit优化")]),t._v(" "),e("p",[t._v("limit在大数据量的情况下，越往后耗时越长")]),t._v(" "),e("p",[t._v("采用覆盖索引+子查询的方式解决")]),t._v(" "),e("div",{staticClass:"language-mysql extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("select * from tb_sku s, (select id from tb_sku order by id limit 9000000,10) a where s.id = a.id;\n")])])]),e("h3",{attrs:{id:"count优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#count优化"}},[t._v("#")]),t._v(" count优化")]),t._v(" "),e("ul",[e("li",[t._v("MyISAM引擎把一个表的总行数存在磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高")]),t._v(" "),e("li",[t._v("InnoDB在执行count(*)的时候，需要把数据一行一行地读出来，然后累积计数，优化思路：自己维护一个数存放count(x)")]),t._v(" "),e("li",[t._v("count(主键)：InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为null）")]),t._v(" "),e("li",[t._v("count(字段)：InnoDB会遍历整张表，把每一行的字段值都取出来，返回给服务层。如果有not null约束，直接累加，如果没有，则服务层会先判断再累加")]),t._v(" "),e("li",[t._v("count(1)：InnoDB引擎遍历整张表，但是"),e("strong",[t._v("不取值")]),t._v("，对于返回的每一行，服务层直接累加")]),t._v(" "),e("li",[t._v("count(*)：InnoDB引擎专门做了优化，"),e("strong",[t._v("不取值")]),t._v("直接累加")]),t._v(" "),e("li",[t._v("按效率排序，count(字段)<count(主键 id)<count(1)≈count(*)，所以尽量使用count(星)")])]),t._v(" "),e("h3",{attrs:{id:"update优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#update优化"}},[t._v("#")]),t._v(" update优化")]),t._v(" "),e("p",[t._v("InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级成表锁")]),t._v(" "),e("p",[t._v("注意事项：在更新时要根据索引字段进行更新，避免行锁升级成表锁")])])}),[],!1,null,null,null);e.default=l.exports}}]);