(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{414:function(t,a,e){"use strict";e.r(a);var v=e(7),r=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("strong",[t._v("本文参考")]),t._v("：[CSDN] 云深i不知处：【Java基础-3】吃透Java IO：字节流、字符流、缓冲流")]),t._v(" "),a("h2",{attrs:{id:"javaio概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javaio概述"}},[t._v("#")]),t._v(" JavaIO概述")]),t._v(" "),a("p",[t._v("IO，即in和out，输入和输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道、网络连接。")]),t._v(" "),a("p",[t._v("Java中是通过流来处理IO的，流（Stream）是一个抽象的概念，是指一连串的数据（字符或字节），是以先进先出的方式发送信息的通道。"),a("strong",[t._v("当程序需要读取数据的时候，就会开启一个通向数据源的流")]),t._v("，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。")]),t._v(" "),a("p",[t._v("输入输出是对程序而言的，数据从其他数据源读入到程序，就是输入；相反从程序内部输出到另外的程序，就是输出。")]),t._v(" "),a("p",[t._v("一般来说关于流的特性有下面几点：")]),t._v(" "),a("ol",[a("li",[t._v("先进先出：最先写入输出流的数据最先被输入流读到")]),t._v(" "),a("li",[t._v("顺序存取：可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据（RandomAccessFile除外）")]),t._v(" "),a("li",[t._v("只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流")])]),t._v(" "),a("h3",{attrs:{id:"io流的分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#io流的分类"}},[t._v("#")]),t._v(" IO流的分类")]),t._v(" "),a("p",[t._v("IO流的主要分类方式有以下3种")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("按数据流的方向：输入流，输出流")]),t._v(" "),a("p",[t._v("输入与输出是对于应用程序而言的，比如文件读写，读取文件是输入流，写文件是输出流")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lunatics.oss-cn-hangzhou.aliyuncs.com/blog/javaio1.png",alt:"img"}})]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[t._v("按处理数据单位：字节流，字符流")]),t._v(" "),a("p",[t._v("字节流和字符流的用法几乎完全一样，区别在于字节流和字符流所操作的数据单元不同，字节流操作的数据单元是8位的字节，字符流操作的数据单元位16位的字符")]),t._v(" "),a("ul",[a("li",[t._v("字节流一般用来处理图像、视频、音频、ppt、word等类型的文件。字符流一般用于处理纯文本类型的文件，如txt文件等，但不能处理图像视频等非文本文件。简单来说："),a("strong",[t._v("字节流可以处理一切文件，而字符流只能处理纯文本文件")])]),t._v(" "),a("li",[t._v("字节流本身没有缓冲区，因此缓冲字节流相对于字节流的效率提升非常高。而字符流本身带有缓冲区，因此缓冲字符流相对于字符流的效率提升并不大")])])]),t._v(" "),a("li",[a("p",[t._v("按功能：节点流，处理流")]),t._v(" "),a("ul",[a("li",[t._v("节点流：直接操作数据读写的类，比如FileInputStream")]),t._v(" "),a("li",[t._v("处理流：对一个已经存在的流的链接和封装，通过对数据进行处理为程序提供功能强大、灵活的读写功能，例如BufferedInputStream。处理流和节点流应用了装饰者设计模式")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lunatics.oss-cn-hangzhou.aliyuncs.com/blog/javaio.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"案例实操"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#案例实操"}},[t._v("#")]),t._v(" 案例实操")]),t._v(" "),a("p",[t._v("需求：将“清晨是彻夜不眠的酒”写入到本地文本，再从文件中读取内容并输出到控制台")]),t._v(" "),a("ol",[a("li",[t._v("FileInputStream、FileOutputStream（字节流）")])]),t._v(" "),a("h2",{attrs:{id:"io流对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#io流对象"}},[t._v("#")]),t._v(" IO流对象")]),t._v(" "),a("h3",{attrs:{id:"file类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#file类"}},[t._v("#")]),t._v(" File类")]),t._v(" "),a("p",[t._v("File类是用来操作文件的类，但它不能操作文件中的数据")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("File")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Serializable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Comparable")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("File")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),a("p",[t._v("可以看到File类实现了Serializable和Comparable接口，说明它支持序列化和排序")]),t._v(" "),a("p",[t._v("File类常见构造方法")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("方法名")]),t._v(" "),a("th",[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("File(File parent,String child)")]),t._v(" "),a("td",[t._v("根据parent路径名和child路径名字符串创建一个新的File实例")])]),t._v(" "),a("tr",[a("td",[t._v("File(String pathname)")]),t._v(" "),a("td",[t._v("通过给定路径名字符串创建一个新的File实例")])]),t._v(" "),a("tr",[a("td",[t._v("File(String parent,String child)")]),t._v(" "),a("td",[t._v("略")])]),t._v(" "),a("tr",[a("td",[t._v("File(URI uri)")]),t._v(" "),a("td",[t._v("通过给定的file:URI转化为路径来创建一个新的File实例")])])])]),t._v(" "),a("p",[t._v("常见API")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("方法")]),t._v(" "),a("th",[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("createNewFile")]),t._v(" "),a("td",[t._v("当且仅当不存在具有此路径名指定名称的文件时，创建一个新的空文件")])]),t._v(" "),a("tr",[a("td",[t._v("delete")]),t._v(" "),a("td",[t._v("删除路径名表示的文件或者目录")])]),t._v(" "),a("tr",[a("td",[t._v("exists")]),t._v(" "),a("td",[t._v("判断此路径名表示的文件或者目录是否存在")])]),t._v(" "),a("tr",[a("td",[t._v("getAbsoluteFile")]),t._v(" "),a("td",[t._v("返回绝对路径名")])]),t._v(" "),a("tr",[a("td",[t._v("getAbsolutePath")]),t._v(" "),a("td",[t._v("返回绝对路径名的字符串")])]),t._v(" "),a("tr",[a("td",[t._v("length")]),t._v(" "),a("td",[t._v("返回文件的长度")])]),t._v(" "),a("tr",[a("td",[t._v("mkdir")]),t._v(" "),a("td",[t._v("创建路径名指定的目录")])])])]),t._v(" "),a("h3",{attrs:{id:"字节流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字节流"}},[t._v("#")]),t._v(" 字节流")]),t._v(" "),a("p",[t._v("InputStream和OutputStream是两个抽象类，是字节流的基类，所有具体的字节流实现类都是粪便继承了这两个类")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("abstract")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InputStream")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Closeable")]),t._v("\n")])])]),a("p",[t._v("以InputStream为例，它继承了Object，实现了Closeable")]),t._v(" "),a("p",[t._v("InputStram类有很多实现子类，下面是一些常用的子类")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lunatics.oss-cn-hangzhou.aliyuncs.com/blog/javaio2.png",alt:"img"}})]),t._v(" "),a("ol",[a("li",[t._v("InputStream：InputStream是所有字节输入流的抽象基类，为所有实现类定义了处理输入流的方法")]),t._v(" "),a("li",[t._v("FileInputStream：文件输入流，用于对文件进行读取操作")]),t._v(" "),a("li",[t._v("PipedInputStream：管道字节输入流，能实现多线程间的管道通信")]),t._v(" "),a("li",[t._v("ByteArrayInputStream：字节数组输入流，从字节数组（byte[]）中进行以字节为单位的读取，也就是将资源文件都以字节的形式存入该类中的字节数组中去")]),t._v(" "),a("li",[t._v("FilterInputStream：装饰者类，具体的装饰者继承该类，这些类都是处理类，作用是对节点类进行封装，实现一些特殊功能")]),t._v(" "),a("li",[t._v("DataInputStream：数据输入流，它是用来装饰其他输入流，作用是允许应用程序以与机器无关方式从底层输入流中读取Java基本数据类型")]),t._v(" "),a("li",[t._v("BufferedInputStream：缓冲流，对节点流进行装饰，内部会有一个缓冲区，用来存放字节，每次都是将缓冲区存满后发送，效率更高")]),t._v(" "),a("li",[t._v("ObjectInputStream：对象输入流，用来提供对基本数据或对象的持久存储。通常用在反序列化中。它也是一种处理流，入参是一个InputStream的实例对象")])]),t._v(" "),a("p",[t._v("OutputStream类继承关系图")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lunatics.oss-cn-hangzhou.aliyuncs.com/blog/javaio3.png",alt:"img"}})]),t._v(" "),a("p",[t._v("OutputStream类继承关系与InputStream类似，需要注意的是PrintStream")]),t._v(" "),a("h3",{attrs:{id:"字符流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符流"}},[t._v("#")]),t._v(" 字符流")]),t._v(" "),a("p",[t._v("与字符流类似，字符流也有两个抽象基类，分别是Reader和Writer。其他的字符流实现类都是继承了这两个类")]),t._v(" "),a("p",[t._v("以Reader为例，子类继承关系如下图")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lunatics.oss-cn-hangzhou.aliyuncs.com/blog/javaio4.png",alt:"img"}})]),t._v(" "),a("ol",[a("li",[t._v("InputStreamReader：从字节流到字符流的桥梁（InputStreamReader构造器入参是FileInputStream的实例对象），它读取字节并使用制定能够的字符集将其解码为字符。它使用的字符集可以通过名称指定，也可以显式给定，或者可以接收平台的默认字符集")]),t._v(" "),a("li",[t._v("BufferedReader：从字符输入流中读取文本，设置一个缓冲区来提高效率。BufferedReader是对InputStreamReader的封装，前者的入参就是后者的一个实例对象")]),t._v(" "),a("li",[t._v('FileReader：用于读取字符文件的便利类，new FileReader(File file)等同于new InputStreamReader(new FileInputStream(file,ture),"UTF-8")，'),a("strong",[t._v("但FileReader不能指定字符编码和默认字节缓冲区大小")])]),t._v(" "),a("li",[t._v("PipedReader：管道字符输入流。实现多线程间的管道通信")]),t._v(" "),a("li",[t._v("CharAaaryReader：从Char数组中读取数据的介质流")]),t._v(" "),a("li",[t._v("StreamReader：从String中读取数据的介质流")])]),t._v(" "),a("p",[t._v("Writer与Reader结构类似，方向相反，不再赘述。唯一的区别是Writer的子类PrintWriter")]),t._v(" "),a("h2",{attrs:{id:"io流方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#io流方法"}},[t._v("#")]),t._v(" IO流方法")]),t._v(" "),a("h2",{attrs:{id:"io题目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#io题目"}},[t._v("#")]),t._v(" IO题目")])])}),[],!1,null,null,null);a.default=r.exports}}]);